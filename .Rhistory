forest= read.table(file = "covtype.data", sep=",", header=TRUE)
str(forest)
library(tidyverse)
library(dplyr)
library(FactoMineR)
library(ggplot2)
library(class)
library(ggplot2) # graph package
library(tinytex) # Pour la sortie pdf
library(corrplot)# Correlation matrix calculus
library(glmnet) # multinomiale avec pénalité lasso
a <- rep("Soil_Type_",40)
for (i in 1:40) {
a[i]<-paste0(a[i],as.character(i))
}
name <- c("Elevation",
"Aspect",
"Slope",
"Horizontal_Distance_To_Hydrology",
"Vertical_Distance_To_Hydrology",
"Horizontal_Distance_To_Roadways",
"Hillshade_9am",
"Hillshade_Noon",
"Hillshade_3pm",
"Horizontal_Distance_To_Fire_Points",
"Wilderness_Area_1",
"Wilderness_Area_2",
"Wilderness_Area_3",
"Wilderness_Area_4",
a,
"Cover_Type")
colnames(forest)<- name
Cov_type = forest$Cover_Type
Xforest <- subset(forest, select = -Cover_Type)
pcaXforest <- PCA(Xforest, ncp = 2)
part_data <- function(data,freq = rep(1/7,7)){
# prend en entree le jeu de donnee à echantillonner et un vecteur de fréquences pour chaque classe dans l'ordre (1 à 7)
# valeur par défaut, toutes les classes sont échantillonnées à peu près à la meme fréquence
# renvoie les indices des individus de l'echantillon d'entrainement et de l'echantillon de validation
nb_indiv <- length(data[,1])
itrain <- c()
itest <- c(1:nb_indiv)
# on force l'echantillon d'entrainement à avoir au moins 3 observations par type de sol
for (i in 15:54) { #les colonnes 14 à 53 sont les colonnes "soil type"
itrain <- c(itrain,sample(x = which(data[,i] == 1 ),size = 3))
}
# on force l'echantillon d'entrainement à avoir au moins 3 observations par type de sol
for (i in 11:14) { #les colonnes" 14 à 53 sont les colonnes "soil type""Wilderness_area"
itrain <- c(itrain,sample(x = setdiff(which(data[,i] == 1 ),itrain),size = 3)) #dans les données pas deja echantilonnee
}
# on force l'echantillon d'entrainement à avoir au moins 1000 observations par type de recouvrement végétal
nb <- freq*7000
for (i in 1:7) {
itrain <- c(itrain,sample(x = setdiff(which(data$Cover_Type == i),itrain),size = nb[i]))
}
itest <- setdiff(itest,itrain)
itest <- sample(itest,3560)
return(list(itrain,itest))
}
table(forest$Cover_Type)
freq_cover <- table(forest$Cover_Type)/length(forest$Cover_Type) # en proportions
par(mfrow=c(2,3))
for (i in 1:10) {
# Cleveland plot
boxplot(forest[,i],pch=16,col='salmon',xlab=colnames(forest)[i])
}
# variables X quantitatives
par(mfrow=c(1,2))
for (i in 1:10) {
boxplot(Xforest[,i]~Cov_type,ylab=colnames(Xforest)[i],xlab = "Cover type")
}
# variables X qualitatives
temp_forest <- Xforest_red
# variables X quantitatives
par(mfrow=c(1,2))
for (i in 1:10) {
boxplot(Xforest[,i]~Cov_type,ylab=colnames(Xforest)[i],xlab = "Cover type")
}
# variables X qualitatives
temp_forest <- Xforest
temp_forest[,11:54][temp_forest[,11:54] == 0] <- NA
temp_forest <- pivot_longer(temp_forest,cols = seq(15,54),names_to = "Soil_type",values_to = "pres_abs", values_drop_na = TRUE)
#moche mais fonctionne
temp_forest <- pivot_longer(temp_forest,cols = seq(11,14),names_to = "Wilderness_area",values_to = "pres_ab", values_drop_na = TRUE)
temp_forest <- temp_forest[,-c(12,14)]
par(mfrow=c(1,2))
mosaicplot(Cov_type~temp_forest$Soil_type
,main="relation Cover type & Soil type")
mosaicplot(Cov_type~temp_forest$Wilderness_area
,main="relation Cover type & Wilderness area")
par(mfrow=c(1,1))
mosaicplot(Cov_type~temp_forest$Soil_type
,main="relation Cover type & Soil type")
mosaicplot(Cov_type~temp_forest$Wilderness_area
,main="relation Cover type & Wilderness area")
M<-cor(Xforest[,1:10])
corrplot.mixed(M,upper="square",lower.col="black", tl.col="black",cl.cex = 0.7,tl.cex = 0.6,number.cex =0.7)
Xforest_red <- Xforest[,-9]
Xforest_red_cr <- Xforest_red
Xforest_red_cr[1:9] <- apply(Xforest_red_cr[1:9],MARGIN = 2,function(X) scale(X,center = TRUE, scale = TRUE))
b=1
rep <- 10 #normalement sur 550 essais mais tournerait environ 36 heures
L_coeffs <- list()
accuracy <- matrix(NA,nrow = rep,ncol = 15)
# subset de données
set.seed(b)
select_indiv <- part_data(forest)
Ytrain <- Cov_type[select_indiv[[1]]]
Ytest <- Cov_type[select_indiv[[2]]]
Xtest <- Xforest_red_cr[select_indiv[[2]],]
# Introduction des interactions dans le modèle
f <- as.formula(Ytrain ~ .+Wilderness_Area_1:Elevation+Wilderness_Area_2:Elevation+Wilderness_Area_3:Elevation+Wilderness_Area_4:Elevation, cbind(Xtrain,Ytrain))
# Second step: using model.matrix to take advantage of f
Xtrain_inter <- model.matrix(f, cbind(Xtrain,Ytrain))[, -1]
Ytrain <- Cov_type[select_indiv[[1]]]
Ytest <- Cov_type[select_indiv[[2]]]
Xtrain <- Xforest_red_cr[select_indiv[[1]],]
Xtest <- Xforest_red_cr[select_indiv[[2]],]
# Introduction des interactions dans le modèle
f <- as.formula(Ytrain ~ .+Wilderness_Area_1:Elevation+Wilderness_Area_2:Elevation+Wilderness_Area_3:Elevation+Wilderness_Area_4:Elevation, cbind(Xtrain,Ytrain))
# Second step: using model.matrix to take advantage of f
Xtrain_inter <- model.matrix(f, cbind(Xtrain,Ytrain))[, -1]
View(Xtrain_inter)
colnames(Xforest_red_cr)
# Introduction des interactions dans le modèle
f <- as.formula(Ytrain ~ .+Wilderness_Area_1:Elevation+
Wilderness_Area_2:Elevation+
Wilderness_Area_3:Elevation+
Wilderness_Area_4:Elevation+
Wilderness_Area_1:Slope+
Wilderness_Area_2:Slope+
Wilderness_Area_3:Slope+
Wilderness_Area_4:Slope+
Wilderness_Area_1:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_2:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_3:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_4:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_1:Horizontal_Distance_To_Roadways+
Wilderness_Area_2:Horizontal_Distance_To_Roadways+
Wilderness_Area_3:Horizontal_Distance_To_Roadways+
Wilderness_Area_4:Horizontal_Distance_To_Roadways,
cbind(Xtrain,Ytrain))
# Second step: using model.matrix to take advantage of f
Xtrain_inter <- model.matrix(f, cbind(Xtrain,Ytrain))[, -1]
# formulation du modèle avec une pénalité lasso
#Xtrain <- matrix(as.numeric(as.matrix(Xtrain)),nrow = nrow(Xtrain))
#Ytrain <- matrix(as.numeric(as.matrix(Ytrain)),nrow = nrow(Ytrain))
mod <- cv.glmnet(Xtrain_inter,Ytrain, alpha=1,family = "multinomial")
ychap <- predict(mod, Xtest,type = "class",s = "lambda.min")
# prédictions du modèle
Xtest <- matrix(as.numeric(as.matrix(Xtest)),nrow = nrow(Xtest))
L_coeffs[[b]] <- coef(mod, s = "lambda.min") #on choisit la pénalité lasso optimale pour le modèle basé sur
ychap <- predict(mod, Xtest,type = "class",s = "lambda.min")
Xtest_inter <- model.matrix(f, cbind(Xtest,Ytest))[, -1]
select_indiv <- part_data(forest)
Ytrain <- Cov_type[select_indiv[[1]]]
Ytest <- Cov_type[select_indiv[[2]]]
Xtrain <- Xforest_red_cr[select_indiv[[1]],]
Xtrain <- Xforest_red_cr[select_indiv[[1]],]
Xtest <- Xforest_red_cr[select_indiv[[2]],]
# Introduction des interactions dans le modèle
f <- as.formula(Ytrain ~ .+Wilderness_Area_1:Elevation+
Wilderness_Area_2:Elevation+
Wilderness_Area_3:Elevation+
Wilderness_Area_4:Elevation+
Wilderness_Area_1:Slope+
Wilderness_Area_2:Slope+
Wilderness_Area_3:Slope+
Wilderness_Area_4:Slope+
Wilderness_Area_1:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_2:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_3:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_4:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_1:Horizontal_Distance_To_Roadways+
Wilderness_Area_2:Horizontal_Distance_To_Roadways+
Wilderness_Area_3:Horizontal_Distance_To_Roadways+
Wilderness_Area_4:Horizontal_Distance_To_Roadways,
cbind(Xtrain,Ytrain))
Xtrain_inter <- model.matrix(f, cbind(Xtrain,Ytrain))[, -1]
#Xtrain <- matrix(as.numeric(as.matrix(Xtrain)),nrow = nrow(Xtrain)) #pour un modèle sans intéractions
mod <- cv.glmnet(Xtrain_inter,Ytrain, alpha=1,family = "multinomial")
#Xtrain <- matrix(as.numeric(as.matrix(Xtrain)),nrow = nrow(Xtrain)) #pour un modèle sans intéractions
mod <- cv.glmnet(Xtrain_inter,Ytrain, alpha=1,family = "multinomial")
L_coeffs[[b]] <- coef(mod, s = "lambda.min") #on choisit la pénalité lasso optimale pour le modèle basé sur
# prédictions du modèle
ychap <- predict(mod, Xtest,type = "class",s = "lambda.min")
# prédictions du modèle
ychap <- predict(mod, Xtest_inter,type = "class",s = "lambda.min")
Xtest_inter <- model.matrix(f, cbind(Xtest,Ytest))[, -1]
cbind(Xtest,Ytest)
model.matrix(f, cbind(Xtest,Ytest))[, -1]
f2 <- as.formula(Ytrain ~ .+Wilderness_Area_1:Elevation+
Wilderness_Area_2:Elevation+
Wilderness_Area_3:Elevation+
Wilderness_Area_4:Elevation+
Wilderness_Area_1:Slope+
Wilderness_Area_2:Slope+
Wilderness_Area_3:Slope+
Wilderness_Area_4:Slope+
Wilderness_Area_1:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_2:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_3:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_4:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_1:Horizontal_Distance_To_Roadways+
Wilderness_Area_2:Horizontal_Distance_To_Roadways+
Wilderness_Area_3:Horizontal_Distance_To_Roadways+
Wilderness_Area_4:Horizontal_Distance_To_Roadways,
cbind(Xtest,Ytest))
Xtest_inter <- model.matrix(f2, cbind(Xtest,Ytest))[, -1]
f2 <- as.formula(Ytest ~ .+Wilderness_Area_1:Elevation+
Wilderness_Area_2:Elevation+
Wilderness_Area_3:Elevation+
Wilderness_Area_4:Elevation+
Wilderness_Area_1:Slope+
Wilderness_Area_2:Slope+
Wilderness_Area_3:Slope+
Wilderness_Area_4:Slope+
Wilderness_Area_1:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_2:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_3:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_4:Horizontal_Distance_To_Fire_Points+
Wilderness_Area_1:Horizontal_Distance_To_Roadways+
Wilderness_Area_2:Horizontal_Distance_To_Roadways+
Wilderness_Area_3:Horizontal_Distance_To_Roadways+
Wilderness_Area_4:Horizontal_Distance_To_Roadways,
cbind(Xtest,Ytest))
Xtest_inter <- model.matrix(f2, cbind(Xtest,Ytest))[, -1]
# prédictions du modèle
ychap <- predict(mod, Xtest_inter,type = "class",s = "lambda.min")
#le modèle fai-il de bonne predictions
acc <- 100*length(which(ychap == Ytest))/3560#on compte le nombre de fois où l'algorithme prédit le bon cover type
for (i in 1:7) {
acc<- c(acc,
100*length(which(ychap == Ytest & Ytest == i))/length(which(ychap == i)),
100*length(which(ychap == Ytest & Ytest == i))/length(which(Ytest == i)))
}
accuracy[b,] <- acc
View(L_coeffs)
L_coeffs[[3]]
L_coeffs[[1]]$`3`
